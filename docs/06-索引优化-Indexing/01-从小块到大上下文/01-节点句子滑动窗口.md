### 總覽
本範例演示以 LlamaIndex 的 `SentenceWindowNodeParser` 構建「句子級檢索 + 視窗上下文」的索引方式。檢索到的命中句會自動攜帶前後各 `window_size` 條句子的上下文，並用 `MetadataReplacementPostProcessor` 在回答階段以「窗口內容」替換原節點文本，兼顧精準與可讀性。

### 流程圖
```mermaid
flowchart TD
  D[Document 原文] --> NP[SentenceWindowNodeParser(window_size=3)]
  NP --> N[帶 window/original_text 的 Nodes]
  N --> IDX[VectorStoreIndex]
  Q[Query] --> QE1[window_query_engine\n+MetadataReplacementPostProcessor(window)]
  Q --> QE2[base_query_engine]
  IDX --> QE1
  IDX --> QE2
  QE1 --> A1[回答 + 窗口上下文]
  QE2 --> A2[回答(僅命中片段)]
```

### 分步講解
- 全域設定：`Settings.llm=DeepSeek`、`Settings.embed_model=BAAI/bge-small-zh`、`SentenceSplitter(chunk_size=50)`。
- 節點切分：`SentenceWindowNodeParser.from_defaults(window_size=3, window_metadata_key="window", original_text_metadata_key="original_text")`。
- 構建兩種索引與查詢引擎：
  - `sentence_index` → `window_query_engine(similarity_top_k=2, node_postprocessors=[MetadataReplacementPostProcessor(target_metadata_key="window")])`。
  - `base_index` → `base_query_engine(similarity_top_k=6)`。
- 對比輸出：前者回答時展示窗口上下文，後者僅展示命中節點文本。

### 關鍵點總結
- **SentenceWindow**：在不擴大檢索粒度的前提下提供充分上下文。
- **MetadataReplacement**：以窗口內容替換節點文本，提升可讀性與答案完整性。
- **實務建議**：對知識點密集但句子短小的文本（FAQ、條款）尤為有效。


